                                            //variable
/*
    命名规则:
            1，变量区分大小写 允许字母 数字 下划线和美元$
            2,第一个字符不允许是数字 空格和其他标点符号
            3,禁止使用javascript关键字 保留字
    匈牙利命名法:
            前面一个字母由变量的类型用一个小写字母代替+后面的变量描述首字母大写以区分类型指示字母
            array 数组 a 
            boolean 布尔值 b
            float 浮点数 f
            function 函数 fn
            int 整数   i
            object 对象 o
            regalar 正则 r 
            string 字符串 s
*/
//ES5规定
//使用变量先声明用 var
var i ;
var sum;
var i,sum;
//与初始赋值写在一起
var message='hello';
var i=0,j=0,k=0;
//如果未给声明的变量赋值它的初始值就是undefined
//javascript的变量声明中并没有指定变量的数据类型，javascript变量可以是任意数据类型
var i=10;
var i='ten'; //完全合法

//变量的作用域即全局与函数在函数体内的变量优先级高于同名的全局变量，由于函数可以嵌套所以都有自己的作用域，
//声明提前：javascript的函数作用域是指在函数内声明的所有变量在函数内始终是可见的，有意思的是变量在声明之前就可用，
//这种特性称为声明提前即javascript函数声明的所有变量被提前至了函数的顶部，但是赋值留在原地。如下例
  var scope='global'
  function fn(){
      console.log(scope);  //输出undifined而不是'global或者local'
      var scope='local';   //声明提前赋值留在原地
      console.log(scope);  //local
  }  
   

//S6 新增了let命令，用来声明变量。它的用法类似于var,我们只说区别，但是所声明的变量，只在let命令所在的代码块内有效
{
  let a=10;
  var b='ten';
}
console.log(a);  // ReferenceError: a is not defined
console.log(b);  //'ten'

//for循环的计数器，就很合适使用let命令 只在循环体内有效出了循环体就会报错。
for(let i=0;i<10;i++){

}
console.log(i) //ReferenceError:a is not defined

//for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
//上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。
//不存在变量提升
// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;

// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
//上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，
//就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。

//不允许重复声明
//let不允许在相同作用域内，重复声明同一个变量。
// 报错
function func() {
  let a = 10;
  var a = 1;
}
// 报错
function func() {
  let a = 10;
  let a = 1;
}
//因此，不能在函数内部重新声明参数。
function func(arg) {
  let arg;
}
func() // 报错
function func(arg) {
  {
    let arg;
  }
}
func() // 不报错

                                                //块级作用域
 //let实际上为 JavaScript 新增了块级作用域。
 function f1() {
   let n = 5;
   if (true) {
     let n = 10;
   }
   console.log(n); // 5
 }
 //上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。

// ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

  // 情况一
  if (true) {
    function f() {}
  }

  // 情况二
  try {
    function f() {}
  } catch(e) {
    // ...
  }
//上面两种函数声明，根据 ES5 的规定都是非法的。
//但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

//ES6引用了块级作用域，明确的允许在块级作用域内使用函数ES6规定，块级作用域之中函数声明的行为类似let在块级作用域外不可以引用
                                            //总结
//作为属性的变量
  /*
    当声明一个javascript全局变量时，实际上是定义了全局对象的一个属性。
    在这里有必要提一下全局对象了
    全局对象是全局定义的符号，javascript程序可以直接使用，当javascript解释器启动时，或加载新页面的时候，它将创建
    一个新的全局对象并给它一组定义的初始属性。
    在客户端javascript中，在表示窗口中所有的javascript代码中 "window" 对象充当了全局对象当然也定义了全局的一些属性
    这个特殊对象同样也包含为程序定义的全局值，如果代码表明了一个全局对象，这个全局变量就是全局对象的一个属性
     
    问题 为什么说使用var创建的属性是不可配置的？
    但是如果你没有使用严格模式并给一个未声明的变量赋值的话javascript会自动创建一个全局变量那么以这种方式创建的变量就是
    可以配置的

    作用域链
    javascript是词法作用域的语言通过阅读包含变量定义在内的行数源源码就能知道变量的作用域，全局变量在程序中始终都是有定义的
    局部变量则是在块级与函数中以及他们所嵌套中
    如果将一个局部变量看做是自定义实现的对象的属性的话那么就可以换一个角度来解读变量的作用域：
      每一段javascript代码(全局 块级 函数)都有一个相关联的作用域链，这个作用域链式一个对象列表或者链表，这组对象
      定义了这段代码“作用域中”的变量
      当javascript需要查找变量x的值的时候，这个过程称为变量的解析，它会从链中的第一个对象开始查找，如果这个对象有一个名为x
      的属性则直接使用这个属性的值，如果第一个对象中没有会继续在链上查找下一对象以此类推如果一直没有找到就会抛出一个引用
      错误RefenceError
    在javascript的最顶层代码中(不包含其他的块级或者函数)作用域链由全局对象组成，有了块级或者函数链上至少有三个对象
    定义一个块级作用域或函数时，它实际上是保存了一个作用域链。
    当调用这个块级作用域或者函数的时候。它创建了一个对象来储存它的局部变量并将这个对象添加至保存的那个作用域链上，
    同时创建一个新的更长的作用域链。
  */