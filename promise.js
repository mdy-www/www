                                                    //javascript何为异步
//进程与线程
    //个程序（program）至少包含一个进程（process），一个进程至少包含一个线程（thread）。
    //进程有以下特点：
    //进程在执行过程中拥有独立的内存单元。
    //一个进程可以创建和撤销另一个进程，这个进程是父进程，被创建的进程称为子进程。
//线程有以下特点：
    //线程不能独立运行，必须依赖进程空间。
    //线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
    //一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。
    //从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

    //所有的程序都要交给CPU实现计算任务，但是CPU一个时间点只能处理一个任务。这时如果多个程序在运行，就涉及到了《操作系统原理》中重要的线程调度算法，线程是CPU轮转的最小单位，其他上下文信息用所在进程中的。
  
    //进程是资源的分配单位，线程是CPU在进程内切换的单位。
//多线程？
    //开启多路线程，每个线程做一件事情，这样就可以同时执行多个任务  
//浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
    //GUI 渲染线程
    //JavaScript引擎线程
    //定时触发器线程
    //事件触发线程
    //异步http请求线程
//JavaScript单线程,那么为什么Javascript要是单线程的？
    //这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。
    //如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。
    //当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。
    //因为JavaScript是单线程的，每个时刻都只能一个事件，所以JavaScript中的同步和异步事件就有了一个奇妙的执行顺序。


//同步与异步？
    //同步就是计算机一行一行按顺序依次执行代码，当前代码耗时执行就是阻塞后续代码的执行，同步编程，即典型的请求-响应模式
    //问题在某些场景下，比如读取文件的内容，或者请求服务器接口数据，需要根据返回的数据内容执行后续操作，读取文件和请求接口直到数据返回这一 过程是需要时间的，网络越差，耗费时间越长，如果按照同步编程方式实 现，在等待数据返回这段时间，JavaScript 是不能处理其他任务的，此时 页面的交互，滚动等任何操作也都会被阻塞，这显然是及其不友好，不可 接受的。
    //多线程结局与单线程异步解决

//单线程的异步？
    //可能非常耗时，而且时间不定长，这时候这些代码就不应该同步执行了，先执行可以执行的代码，在未来的某个时间再来执行他们的handler，这就是异步。
    //异步就是可以实现多个任务并发执行。
    //这里说一下并行与并发，上面提到了多线程，多线程可以并行执行。而JavaScript单线程异步编程可以多任务并发执行，这里并行与并发的区别有必要说一下，
    //并行，指同一时刻多任务同时进行，而javascrip单线程我们需要异步执行，指在同一时间段内，多任务同时进行着，但是某一时刻，只有某一任务执行。
    //既然在说javascript我们就讲一下并发模式
    //目前。我们知道JavaScript执行异步任务时，不需要等待响应返回，可以继续执行其他任务，而在响应返回时，会得到通知，执行回调或事件处理程序，（回调和事件处理本质并无区别，只是在不同 情况下，不同叫法）
    //而javascript异步多个任务并发可以实现并发执行，而实现这一功能的基础是javascript拥有一个基于事件循环的并发模型
//阻塞和非阻塞
    //这时候再理解阻塞非阻塞就好理解了，对于异步任务，单线程的JavaScript如果什么也不干等待异步任务结束，这种状态就是阻塞的；如果将异步消息放到一边，过会再处理，就是非阻塞的。
    //请求不能立即得到应答，需要等待，那就是阻塞；否则可以理解为非阻塞。

//介绍几个概念
    //介绍 JavaScript 并发模型之前，先简单介绍堆栈和队列的区别：
    //堆 ：内存中某一未被阻止的区域，通常存储对象(引用类型)
    //栈 ：后进先出的顺序存储数据结构，通常存储函数参数，和基本类型值变量(按值访问) 
    //队列：先进先出顺序存储数据结构。
    //javasvript引擎负责解析，执行javascript代码，单它并不能单独运行，通常都有一个宿主环境，一般如浏览器或node服务器前文说到的单线 程是指在这些宿主环境创建单一线程，提供一种机制，调用 JavaScript 引 擎完成多个 JavaScript 代码块的调度，执行（是的，JavaScript 代码都是按 块执行的），这种机制就称为事件循环（Event Loop）。
  
//执行环境中存在两个结构需要了解一下。
    //1：队列 消息队列，也叫任务队列，存储待处理消息及对应的回调函数或事件处理程序
    //2: 栈   执行栈也叫执行上下文,javascript执行栈，顾明思议，是由执行上下文组成，当函数调用时，创建并插入一个执行上下文，通常称为执行栈帧，存储着函数参数和局部变量，当该函数执行结束时，弹出该执行帧
    //关于全局代码，由于所有代码都是在全局上下文执行，所以执行栈顶总是全局上下文就容易理解，直到所有代码执行完毕，全局上下文退出执行栈，栈清空了。
    //因为JavaScript是单线程的，每个时刻都只能一个事件，所以JavaScript中的同步和异步事件就有了一个奇妙的执行顺序。
    //JavaScript在运行时（runtime）会产生一个函数调用栈，先入栈的函数先被执行。但是有一些任务是不需要进入调用栈的，这些任务被加入到消息队列中。当函数调用栈被清空时候，就会执行消息队列中的任务（任务总会关联一个函数，并加入到调用栈），依次执行直至所有任务被清空。由于JavaScript是事件驱动，当用户触发事件JavaScript再次运行直至清空所有任务，这就是事件循环。
    //函数调用栈中的任务永远优先执行，调用栈无任务时候，遍历消息队列中的任务。消息队列中的任务关联的函数（一般就是callback）放入调用栈中执行。    
    
    //举个例子
    function ajax (url, callback){
        var req = new XMLHttpRequest();
    
        req.onloadend = callback;
        req.open('GET', url, true);
        req.send();
    };
    
    console.log(1);
    ajax('/api/xxxx', function(res){
        console.log(res);
    });
    console.log(2);
    //javascript事件调动发起的单线程如下
    //首先的执行顺序: 调用栈---console.log(1)---->ajax设置的请求--->console.log(2)---------->function(res){console.log(res)}-->
    //                                           |                                         ^
    //                                           V                                         |  
    //              消息队列----------------------------------------------------------ajax回调的消息
    //                                           |                                          ^
    //                                           V                                          |
    //网络请求线程(浏览器内核多线程处理机制)-----发送等待请求返回-------------------------------- ----->                               

    //调用栈执行console.log(1);。
    //调用栈执行ajax方法，方法里面配置XMLHttpRequest的回调函数，并交由线程执行异步请求。
    //调用栈继续执行console.log(2);。
    //调用栈被清空，消息队列中并无任务，JavaScript线程停止，事件循环结束。
    //不确定的时间点请求返回，将设定好的回调函数放入消息队列。
    //事件循环再次启动，调用栈中无函数，执行消息队列中的任务function(res){console.log(res);}。
    
//定时器任务：

    // console.log(1);
    // setTimeout(function(){
    //     console.log(2);
    // }, 100);
    // setTimeout(function(){
    //     console.log(3);
    // }, 10);
    // console.log(4);
    // 1
    // 4
    // 3
    // 2

//执行顺序如下：

   //调用栈执行console.log(1);。
   //执行setTimeout向消息队列添加一个定时器任务1。
   //执行setTimeout向消息队列添加一个定时器任务2。
   //调用栈执行console.log(4);。
   //调用栈执行完毕执行消息队列任务1。
   //调用栈执行完毕执行消息队列任务2。
   //消息队列任务2执行完毕调用回调函数console.log(3);。
   //消息队列任务1执行完毕调用回调函数console.log(2);。

//异步解决方法
  //虽然已经理解了JavaScript中运行异步任务的过程，但是这样显然对开发不友好，因为我们通常并不知道异步任务在何时结束。所以前人开发了多种处理异步的方法。每种方法我们都从三个角度考虑其优缺点：
  //单个异步写法是否简便。
  //多个异步按顺序执行。
  //多个异步并发执行。
//回调函数 （callback）
  //一种最常见的处理异步问题的方法，将异步任务结束时候要干的事情（回调函数）作为参数传给他，等任务结束时候运行回调函数。
  //我们常用的$.ajax()和setTimeout都属于这种方式，但是这样的问题很明显：多个异步任务按顺序执行非常恐怖。
        asyncEvent1(()=>{
            asyncEvent2(()=>{
                asyncEvent3(()=>{
                    asyncEvent4(()=>{
                        ....
                    });    
                });
            });
        });














    var eventLoop=[];
    var event;
    var i=eventLoop-1;
    while(eventLoop[i]){
        event=eventLoop[i--]
        if(even){
            event()
        }
    }









//定义
//promise的含义promise是异步编程的一种解决方案，比传统的解决方案--回调函数和事件，更加合理和强大ES6将其写进了语言的标准。统一了用法，原生提供了promise对象
//解释
//所谓promise,简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）并提供了统一的API,


